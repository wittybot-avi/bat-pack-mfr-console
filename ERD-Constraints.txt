ERD-level entity groups
A) Tenancy and access control
orgs


org_id (PK), name, created_at


plants


plant_id (PK), org_id (FK), name, location, created_at


users


user_id (PK), org_id (FK), email (unique), name, status, created_at


role_clusters


role_id (PK) e.g. C1_LEADERSHIP … C9_EXTERNAL, SUPER


label, description


user_roles


user_id (FK), role_id (FK)


optional scopes: scope_plant_id, scope_customer_id


composite PK on (user_id, role_id, scope_plant_id, scope_customer_id)


rbac_screen_ids (optional registry)


screen_id (PK) e.g. BATCHES_LIST, DISPATCH_LIST, COMPLIANCE, RBAC_VIEW


rbac_policy_versions (optional)


policy_version (PK), published_at, published_by
rbac_grants


policy_version (FK), role_id (FK), screen_id (FK), actions_json



If you want the UI’s “Access Control” to be fully consistent, keep policy server-side and version it.


B) Master data
variants


variant_id (PK), org_id (FK)


code, name, attrs_json, created_at


stations


station_id (PK), org_id (FK), plant_id (FK)


name, type (PROVISIONING, EOL_QA, CALIBRATION)


status, meta_json


profiles


profile_id (PK), org_id (FK)


kind (PROVISIONING, EOL_QA)


name, version, is_active, payload_json, created_at


locations (inventory + custody)


location_id (PK), org_id (FK), plant_id (FK nullable)


type (RACK, QUARANTINE, DOCK, YARD, CUSTOMER_SITE)


name, geo_json (optional)


customers


customer_id (PK), org_id (FK)


name, type (OEM, FLEET, DISTRIBUTOR), meta_json



C) Manufacturing core workflow
batches


batch_id (PK), org_id (FK), plant_id (FK)


batch_code (unique per org), variant_id (FK)


planned_qty, status (OPEN, CLOSED, CANCELLED)


created_by (FK users), created_at, closed_at


batteries


battery_id (PK), org_id (FK), plant_id (FK)


batch_id (FK), variant_id (FK)


serial (unique), qr_code, created_at


read-model fields (derived):


provisioning_status (NOT_STARTED/IN_PROGRESS/PASS/FAIL)


eol_status (NOT_STARTED/PASS/FAIL)


inventory_status (IN_STOCK/RESERVED/QUARANTINED/IN_TRANSIT)


custody_status (AT_FACTORY/IN_TRANSIT/RECEIVED/ACCEPTED/REJECTED)


current_location_id (FK locations, nullable)


current_dispatch_id (FK dispatch_orders, nullable)


warranty_status (NONE/OPEN/DECIDED/CLOSED)





Backend rule: no direct “edit” of these statuses except via events (below). They can be stored here for UI speed.


D) Provisioning
provisioning_sessions


session_id (PK), org_id (FK)


station_id (FK), battery_id (FK), profile_id (FK)


status (CREATED/STARTED/COMPLETED/FAILED)


result (PASS/FAIL nullable)


firmware_version, calibration_ref, notes


created_by, created_at, started_at, completed_at


provisioning_steps (optional for detailed trace)


step_id (PK), session_id (FK)


name, status, started_at, ended_at, data_json



E) EOL / QA
qa_runs


run_id (PK), org_id (FK)


station_id (FK), battery_id (FK), profile_id (FK)


status (CREATED/COMPLETED)


result (PASS/FAIL)


certificate_ref


measurements_json


created_by, created_at, completed_at


qa_measurements (optional, if you want queryable metrics)


run_id (FK), metric_code, value_num, value_text, unit


composite PK (run_id, metric_code)



F) Inventory (append-only movements)
inventory_movements (source of truth)


movement_id (PK), org_id (FK)


battery_id (FK)


from_location_id (nullable), to_location_id (nullable)


reason (PUTAWAY/MOVE/QUARANTINE/RELEASE/RESERVE/UNRESERVE/PICK)


reference_type (DISPATCH/QA/WARRANTY/ADHOC)


reference_id


actor_user_id, created_at


notes


inventory_reservations (optional)


reservation_id (PK), org_id (FK)


battery_id (FK), reservation_ref


status (ACTIVE/RELEASED)


created_at, released_at



G) Dispatch
dispatch_orders


dispatch_id (PK), org_id (FK), plant_id (FK)


customer_id (FK), destination_location_id (FK locations)


carrier_name, status (DRAFT/READY/DISPATCHED/CANCELLED)


ship_date, tracking_ref


created_by, created_at, updated_at


dispatch_items


dispatch_id (FK), battery_id (FK)


composite PK (dispatch_id, battery_id)



H) Custody (append-only events = truth)
custody_events (source of truth)


event_id (PK), org_id (FK)


dispatch_id (FK), event_type (DISPATCHED/RECEIVED/ACCEPTED/REJECTED)


actor_user_id, actor_role


location_text, reason_code, notes


payload_json


created_at


custody_state (optional read model per dispatch)


dispatch_id (PK/FK)


status (IN_TRANSIT/RECEIVED/ACCEPTED/REJECTED)


last_event_at



Battery-level custody status is derived from dispatch custody (or from per-battery custody events if you later split shipments).


I) Warranty (claims + events)
warranty_claims


claim_id (PK), org_id (FK)


battery_id (FK), customer_id (FK)


status (OPEN/UNDER_ANALYSIS/AWAITING_EVIDENCE/DECIDED/CLOSED)


priority (LOW/MED/HIGH/CRITICAL)


failure_category (MANUFACTURING_DEFECT/QA_ESCAPE/LOGISTICS_DAMAGE/FIELD_MISUSE/AGING_WEAR/UNKNOWN)


symptoms_text


assigned_to (FK users nullable)


decision_json (nullable)


created_by, created_at, updated_at, closed_at, closure_notes


warranty_events (append-only)


event_id (PK), claim_id (FK)


event_type (CREATED/EVIDENCE_REQUESTED/EVIDENCE_ADDED/DECIDED/CLOSED/COMMENT)


payload_json, actor_user_id, created_at



J) Compliance and evidence
compliance_findings


finding_id (PK), org_id (FK)


title, type (PROCESS/QUALITY/TRACEABILITY/DATA_INTEGRITY)


severity (LOW/MED/HIGH/CRITICAL)


status (OPEN/IN_REVIEW/CLOSED)


linked_type (battery/batch/dispatch/claim)


linked_id


notes


created_by, created_at, updated_at


evidence_packs (optional, or generate on-demand)


pack_id (PK), org_id (FK)


scope (battery/batch/dispatch), scope_id


format (json/pdf), generated_by, created_at


payload_json or file_id



K) Files and attachments
files


file_id (PK), org_id (FK)


purpose (WARRANTY_EVIDENCE/CUSTODY_EVIDENCE/COMPLIANCE_EVIDENCE)


file_name, mime_type


storage_key, size_bytes


created_by, created_at


entity_attachments


entity_type (claim/custody_event/finding)


entity_id


file_id (FK files)


composite PK (entity_type, entity_id, file_id)



L) Audit (mandatory)
audit_log (append-only)


audit_id (PK), org_id (FK)


actor_user_id, actor_role


action (string enum-like)


entity_type, entity_id


before_json, after_json


request_id, ip, user_agent


created_at



Key relationships (the “workflow chain”)


batches (1) -> batteries (N)


batteries (1) -> provisioning_sessions (N)


batteries (1) -> qa_runs (N)


batteries (1) -> inventory_movements (N)


dispatch_orders (1) -> dispatch_items (N) -> batteries


dispatch_orders (1) -> custody_events (N)


batteries (1) -> warranty_claims (N)


warranty_claims (1) -> warranty_events (N)


compliance_findings can link to any of the above via (linked_type, linked_id)



State derivation rules (so backend doesn’t “fight” UI)


Battery provisioning status


latest provisioning_sessions by completed_at decides PASS/FAIL




Battery EOL status


latest qa_runs decides PASS/FAIL




Inventory status/location


latest inventory_movements decides current location + state




Custody status


latest custody_events for the dispatch the battery is on




Warranty status


latest claim status (or active claim exists)




Implement as:


transactional update to batteries read model on each event completion, or


materialized view / event projector.



Telemetry note (recommended)
Do not store raw telemetry in Postgres long-term.


Use TSDB (TimescaleDB/InfluxDB) or object storage + query layer.


Keep in Postgres:


telemetry_latest (battery_id, last_seen_at, soc, soh, temp, voltage)


optional telemetry_summary_daily for analytics.





Minimal indexes (must-have)


batteries(serial) unique


batteries(batch_id), batteries(current_dispatch_id)


provisioning_sessions(battery_id, completed_at desc)


qa_runs(battery_id, completed_at desc)


inventory_movements(battery_id, created_at desc)


dispatch_items(battery_id)


custody_events(dispatch_id, created_at desc)


warranty_claims(battery_id, created_at desc)


compliance_findings(linked_type, linked_id)



